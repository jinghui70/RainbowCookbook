{"./":{"url":"./","title":"简介","keywords":"","body":"简介 Rainbow 开发平台是一个基于 java 的业务开发平台，它的设计原则是尽可能的简单，其设计目标如下： 解耦代码，易于扩展 数据库无关 面向服务开发 开发简单，让开发人员聚焦于业务开发，不在系统的管理配置上浪费时间 测试简单，保证代码质量 部署简单，支持局部代码热更新 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-20 09:59:28 "},"Introduction.html":{"url":"Introduction.html","title":"基本结构","keywords":"","body":"基本结构 狭义的 Rainbow 从狭义的角度来说，整个平台就是一个核心的包core.jar，只有 300 多 K，它提供了以下的内容： 插件管理机制 扩展机制 一些基础的工具类 除了core.jar以外，所有的代码都以插件的形式存在。相关功能的 java 代码组成一个插件，我们称之为 Bundle。Bundle 在部署运行状态是一个 jar 文件，存放在 bundle 目录下；在开发状态，每个 Bundle 就是一个 java 工程。 Rainbow 的 Bundle 与 Eclipse 的 plugin 概念是一样的，Eclipse 有各种各样的 plugin，第三方也可以开发自己的 plugin 放在 Eclipse 的 plugins 目录下，这是 Eclipse 如此强大的原因之一。 Rainbow 复刻了 Eclipse 的插件机制和扩展机制并做了简化，也是希望和 Eclipse 一样灵活且强大。 广义的 Rainbow 从广义的角度来说，Rainbow 平台还提供了许多平台级的基础插件，形成了自己的生态系统。这些插件包括： 数据库访问插件 服务管理插件 未来还会提供更多的基础插件，让开发人员聚焦于业务开发，不用在系统的管理配置上浪费时间。 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-02-13 15:07:08 "},"Develop.html":{"url":"Develop.html","title":"建立开发环境","keywords":"","body":"建立开发环境 Rainbow 开发是建立在 Eclipse 环境下的，准备开发一个系统的时候，首先要用 Eclipse 为这个系统建一个 Workspace，这个系统的所有代码都在这个工作空间的目录下，保证所有开发人员的开发环境的一致性。这样，每当有新人加入团队开发这个项目的时候，只需要把别人的 Workspace 目录拷贝过来即可，什么都不用改。 Rainbow 的开发设定 使用 Ant 打包部署管理并开发中的一些问题，不使用 Maven。 统一管理第三方 jar, 不使用 Maven。 使用 Slf4j/Logback 记录日志 主控项目 Workspace 中有一个名为 rainbow 的主控 Java Project，也是平台的入口所在，其目录结构及说明如下： src 这是项目的 Source Folder，放置开发时的日志配置文件 logback.xml conf 配置文件目录 build.xml Ant 构建脚本 library.json 第三方 Jar 文件描述 以下目录及文件是生成出来的，不需要放进 Source Control 系统 [build] 打包用的文件目录 [bundle] 预置插件目录 [lib] 第三方 jar 以及core.jar所在目录 [deploy.zip] Rainbow 平台部署版本 [dev.zip] Rainbow 平台开发版本 [version.txt] Rainbow 平台的版本 build.xml 在 Eclipse 中，点击菜单 Window->Show View->Ant, 打开 Ant View，并把 build.xml 拖进这个 View 中，可以看到这个构建脚本的所有命令： library：这个命令会根据 library.json 中的配置下载所有的第三方 jar 到 lib 目录下，并生成一个 rainbow.userlibraraies 文件，在 Preferences 中选择 Java->Build Path->User Libraries，点击 import 导入这个文件，就可以配置好一个名为 Rainbow Library 的用户库，所有的插件工程的 ClassPath 都需要包括这个用户库。 upgrade-rainbow：这个命令会下载最新版本的 Rainbow 平台文件（deploy.zip 和 dev.zip），并在主控目录下解压 dev.zip，同时调用 library 命令。 deploy：这个命令将打包整个系统为一个部署目录 makeDevelopDatabase：这个命令根据数据库设计及测试数据生成开发用的数据库 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-16 18:29:29 "},"Bundle.html":{"url":"Bundle.html","title":"插件","keywords":"","body":"插件 基本概念 每个插件开发时对应的是一个 eclispe 的 project 插件的 id 就是 project 的名字 src 根目录下应该有 bundle.xml 文件描述插件的信息 项目的根 package 与插件 id 一致，也就是与 project 名字一致 根 package 下有 Activator 类，这个是插件启动、停止的控制类，由平台控制 bundle.xml 插件的id 插件的描述 db service parent 定义的是依赖的其它插件，运行时，平台会把这些父插件加入当前插件的 classpath。开发时，因为没做解析这个描述文件的工作，所以还要手动的把插件包或者 project 加入开发的 build path Activator activator 是插件与外部世界的界面 activator 维护了一个 Bean Context，插件启动时，所有单例 Bean 都会被加载。 当我们写的一个 Bean 需要用到 activator 时，可以继承 ActivatorAwareObjectd 对象或者实现 ActivatorAware 接口，平台就会为它注入 activator。一般我们注入 activator 都是为了获取插件的配置信息 重载 doStart 函数可以实现插件启动时的一些操作或者请求一些资源，一般我们在这里注册扩展点 重载 stop 函数可以实现插件停止时释放资源 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-16 18:34:21 "},"IOC.html":{"url":"IOC.html","title":"依赖注入","keywords":"","body":"依赖注入 依赖注入（Dependency Injection），或者叫控制反转（Inversion of Control），是 Spring 最早的基础功能之一。Rainbow 借鉴了早期 Spring 的代码，自己定义了一个简单的 IOC 容器。 容器中存放的东西，被称为 Bean。Bean 有两种，一种叫单例 Bean，容器只会为它创建一个实例，每次获取这个 Bean，得到的都是同一个对象；另一种叫原型 Bean，每次获取这个 Bean，容器都会创建一个新的实例，并为其注入所有的依赖。 如果熟悉 Spring，这些都是基本概念。并且 Bean 如果实现InitializingBean、DisposableBean 这些接口，概念和 Spring 是一致的。 因为简化了的原因，我们只支持属性注入，这意味这每个 Bean 都必须有无参数的缺省构造函数。在需要注入依赖的属性或者 set 方法上，加上@Inject 注解即可。 Bundle 的 Bean 容器 每一个 Bundle，都是由 Activator 管理生命周期的，平台启动 Bundle 时，会创建其 Activator 的实例，Activator 维护了一个 IOC 容器，称之为 Bundle 的 Bean 容器。 只要在一个类的定义上面添加 @Bean 注解，就可以配置为容器中的 Bean。 配置一个单例 Bean，并设置 BeanName 为 sample： @Bean(name=\"sample\") public class SampleSingleton { } 配置一个 原型 Bean @Bean(singleton=false) public class SamplePrototype { } 如果不设置 BeanName，默认的 BeanName 为第一个字母小写的类的名字，上面的例子中就是 samplePrototype。 几个重要的点： 有一个特别的约定，如果类名以 Impl 为结尾，默认的 BeanName 会忽略它。比如 UserServiceImpl 这个类的 BeanName 为 userService。 插件是单向依赖的，插件的容器在为其 Bean 注入依赖的时候，如果在自己的容器中找不到，会到其上级插件容器中寻找。 有时候某个 Bean 需要访问插件的 Activator(参见访问配置文件)，如果它实现了 ActivatorAware 接口或者派生自 ActivatorAwareObject，容器会把插件的 Activator 注入给它。 如果一个 Bean 同时是一个扩展，那么它无需手动注册，只要在注解中标示出来就可以了。 另外需要了解的是，。 Bean 容器的底层实现 以下内容揭示类容器的实现原理，可以参考看一下，不用深究。 最基本的容器是Context类实现的，Bean 的配置使用一个Map作为参数传递给 Context 的构造函数。 ApplicationContext 派生自 Context，不同的是它注册了一个 InjectProvider 扩展点。实现了该扩展点的扩展可以把外部对象注入到有需要的 Bean 中。比如数据库访问对象 Dao 由 DaoManager 管理，所以有一个 Dao 的 InjectProvider 扩展，这样，ApplicationContext 发现某些 Bean 需要注入 Dao 对象时，就会找到这个扩展来获取需要注入的对象。 Bundle 的容器 BundleContext 派生自ApplicationContext Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-20 11:38:39 "},"Config.html":{"url":"Config.html","title":"配置文件","keywords":"","body":"配置文件 每个 Bundle 都可以有自己的配置文件。配置文件都统一存放在主控目录下的 conf 目录中，我们称它为配置主目录。配置主目录下，有平台的主配置文件core.json。 简单的配置需求 如果插件对配置的需求比较简单，可以在配置主目录下放置同名的 json 文件存储配置信息，也可以在配置主文件里加一个同名的配置项。 比如 com.sample.socket 插件需要配置启动端口和欢迎词，在配置主目录下建立名为com.sample.socket.json的配置文件，内容如下： { \"port\": 8888, \"welcome\": \"欢迎光临\" } 也可以在配置主文件 core.json 中加入以下内容： { \"com.sample.socket\": { \"port\": 8888, \"welcome\": \"欢迎光临\" } } 独立的配置文件与寄生在主配置文件中的效果是一样的，一般情况下建议使用独立的配置文件。平台提供了 ConfigData 类用来获取配置信息： ConfigData configData = activator.getConfig(); int port = configData.getInt(\"port\"); String text = configData.getString(\"welcome\"); 上面的代码可以看到 ConfigData 是用 activator 获取的，那么如何获取 activator 呢？ 写一个 Bean，派生自ActivatorAwareObject 或者实现ActivatorAware接口，activator 就会被自动注入。 在上面的例子中，如果定义一个 ServerConfig 类来对应配置内容： class ServerConfig { private int port; private String welcome; ... set/get } 现在希望直接把配置内容读取为这个类的一个实例对象，可以这样实现： @Bean class SampleCode extends ActivatorAwareObject implements InitializingBean { private ServerConfig serverConfig; @Override public void afterPropertiesSet() { serverConfig = activator.parseConfigFile(ServerConfig.class); ... } } 复杂的配置需求 当一个插件的配置文件不止一个，或者配置文件不是 json 格式时，需要在配置主目录下建立插件同名的子目录，把所有的配置文件都放在这个目录下。我们看到 conf/db 目录下就有数据库连接配置文件 database.xml 和数据模型描述文件 xxx.rdmx 等。BundelActivator 类提供类许多函数帮助获取配置信息： Path getConfigureFile(String fileName) // 获取指定名字的文件对象 List getConfigureFiles(final String suffix) // 获取指定后缀的所有文件 T parseConfigFile(final String fileName, Class clazz) // 把一个json格式的文件转为指定对象 开发期配置 有时候，开发时用到的配置与运行期不一样（比如开发的数据库连接与发布数据库连接是不同的），只需要在配置文件后面加上.dev 后缀就可以了，开发时会优先寻找该后缀的配置文件，打包发布的时候，这个后缀的文件都会被忽略掉。 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 00:51:22 "},"Session.html":{"url":"Session.html","title":"Session","keywords":"","body":"Session 对于外界的每一个请求，都是运行在一个线程中的。如果需要，系统提供了一个 Session 类，用于维护一个线程内的 Map。 不同于 J2EEServer，这个 Session 不是必须的，是否使用取决于系统设计者的想法。比如他可以把用户 ID 放在 Session 中，也可以在每个服务函数中增加用户 ID 参数而不用 Session。 Session 中的值应该在服务调用前设置好，如果访问时没有设置，会抛出 SessionException。 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 17:04:23 "},"Converter.html":{"url":"Converter.html","title":"数据类型转换","keywords":"","body":"数据类型转换 把数据从一种类型转为另一种类型，这是一个普遍的需求，因此 Converters 类提供了下面的转换函数： T convert(F from, Class toClass); 目前支持以下类型的数据转换： Boolean2Number Date2Long Date2SqlDate Date2Timestamp Enum2Number Enum2String LocalDate2SqlDate LocalDate2Timestamp LocalDateTime2Timestamp Number2BigDecimal Number2Boolean Number2Date Number2Enum Number2Double Number2Int Number2Long Number2Short Object2String SqlDate2LocalDate String2BigDecimal String2Boolean String2Date String2Double String2Enum String2Int String2Long String2Short String2SqlDate String2Timestamp String2LocalDate String2LocalDateTime Timestamp2Date Timestamp2LocalDate Timestamp2LocalDateTime 另外，还支持 Java Bean 与 Map 的互转： Map object2Map(T object); T map2Object(Map map, Class clazz); Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-16 18:33:25 "},"Utils.html":{"url":"Utils.html","title":"工具类","keywords":"","body":"工具类 常用工具 MD5 DoubleUtils Utils Preconditions Guava 由 Google 提供的开源 java 库 加密 Encryption 扩展点 EncryptUtils 拼音 PinYin 模版引擎 Template 预定义对象 接口： IIdObject INameObject ICodeObject ITreeObject 类： IdObject IdNameObject TreeObject TreeNode, Tree Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-20 12:29:03 "},"Extension.html":{"url":"Extension.html","title":"扩展与扩展点","keywords":"","body":"扩展与扩展点 当有一类相似的事情需要统一管理的时候，而这类事情未来还可能会增加，这就是使用扩展机制的好时机。我们现在的代码中有很多用到扩展的例子： 任务调度 调度只负责处理任务执行相关逻辑，具体任务类型有很多，而且未来还会增加。只要定义任务类型扩展点，未来新增的插件中实现这个扩展点定义的接口，就可以自动增加新的任务类型，该类型的任务就可以加入任务池由调度管理了。 待办事项 待办事项与任务调度相似，待办事项类型扩展点定义了管理规范，具体实现的扩展处理各自个性化的业务。 字段加工厂(Refinery) 针对不同的字段类型做加工，比如日期型的可以做计算后转义，代码型的可以翻译，随着需要可以随时增加新的加工厂。这样查询的时候就可以有更丰富的结果了。 扩展可以存在于不同于扩展点的 Bundle 中，所以未来的扩展是通过不断的增加插件来完成的，这样做的好处是把处理机制和具体的处理逻辑做了很好的解耦，系统可以无限扩展而不用改动原有代码。 扩展点定义与使用 扩展点定义的是要管理的规范，一般情况下就是一个简单的 java 接口。建议这个 java 接口实现 INameObject，这样每个扩展都有一个 name 属性，将来可以用名字来找对应的扩展。 public interface SampleExtensionPoint extends INameObject { ..... } 定义好扩展点接口，需要在插件的 Activator 中注册这个扩展点。 protected void registerExtensionPoint() throws BundleException { registerExtensionPoint(SampleExtensionPoint.class); } 使用的时候，ExtensionRegistry 提供了很多获取扩展的函数，可以根据 name，或者 class 来获取指定的扩展对象，也可以获取所有已注册的扩展名字或对象列表。下面是最常用的三个函数： ExtensionRegistry.getExtensionObject(SampleExtensionPoint.class, \"E\") 得到name为E的SampleExtensionPoint对象 ExtensionRegistry.getExtensionObjects(SampleExtensionPoint.class) 得到 List ExtensionRegistry.getExtensionNames(SampleExtensionPoint.class) 得到 List 扩展实现 具体的扩展对象就是一个类，只要实现了扩展点的接口，注册在平台扩展注册表就可以了。 扩展必须是单例的，最简单的办法就是定义它为一个单例的 Bean，并在 @Bean 里面注明它实现了哪个扩展点接口。 @Bean(extention=SampleExtensionPoint.class) public class E implements SampleExtensionPoint { @Override public String getName() { return \"E\"; } .... } Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-19 14:31:32 "},"Database.html":{"url":"Database.html","title":"设计目标","keywords":"","body":"数据库访问设计目标 数据库访问由 db 插件提供，所有需要访问数据库的 Bundle 都应该依赖这个插件。 Rainbow 的数据库访问，是一个自洽且开放的设计，底层使用了 Spring 的 JdbcTemplate 设计并天然支持 O-R Mapping，全部的访问方法被封装到一个接口 Dao 之内。 设计的原则依然是简单，希望达到的目标如下： 目标一：与具体数据库无关 使用统一的逻辑数据类型，定义如下： public enum DataType { SMALLINT, INT, LONG, DOUBLE, NUMERIC, DATE, TIME, TIMESTAMP, CHAR, VARCHAR, CLOB, BLOB; } 参考 Hibernate 为不同数据库实现了分页、函数等不同语法的数据库方言。 目标二 数据库结构设计、测试库结构、开发库结构要一致，数据库结构设计变动可追溯 数据库结构属于代码的一部分，因此我们用 json 结构保存数据库模型，并放置于 db 插件的配置目录下。创建数据库的脚本都是通过工具从这个模型文件产生的，保证了库结构的一致性；同时模型文件是文本文件，保存在源码管理系统中可以很好的进行版本控制。 目标三 尽量使用简单的 SQL 语法，让代码易读 过于复杂的 SQL 语句对于代码阅读来说是非常困难的，特别是不同人维护的时候，因此不建议使用。复杂的 SQL 可以通过拆分或者使用后面描述的高级操作来实现。 当极端要求性能，必须使用特定数据库语法时，dao 也提供了透明的直接发送 SQL 语句的函数，但是这样就破坏了数据库无关性，需要使用者抉择。 目标四 团队开发互不影响 如果开发时团队成员都依赖同一个开发库，库结构的改动，测试数据的变化都会导致混乱。rainbow 开发建议使用本地的数据库，在 build.xml 脚本中有 makeDevelopDatabase 命令可以一键生成新的开发数据库并灌入初始化数据与测试数据，保证了开发的效率。 测试团队也可以一键部署测试库，与开发团队隔离，保证系统的质量。 随着硬件的发展，开发机器性能越来越强，本地部署一个 Oracle、MySQL 都很容易了，但是基于简单的角度，建议使用 H2 数据库开发。makeDevelopDatabase 命令默认会在用户目录下建立一个 db 目录，并在其中生成 H2 的数据库文件。 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 02:02:22 "},"RDM.html":{"url":"RDM.html","title":"数据模型","keywords":"","body":"数据模型 数据库的结构，也称为数据模型，是用一个后缀名为 .rdmx 的 JSON 文件来保存的，目前使用 RainMaker 这个工具来维护。 每一个 rdmx 文件，都保存了一个 Model 对象，代表了一个逻辑数据库的设计；Model 的 name 属性就是这个逻辑数据库的名字。 Model 包含了许多的 Entity 对象，对应数据库中的数据表，Entity 的 name 属性即为它映射的对象名，必须以大写字母开头； Entity 对象包含 Column 对象，对应数据表字段， Column 的 name 属性即为它映射的对象属性名，必须以小写字母开头。 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 02:17:52 "},"DatabaseConfig.html":{"url":"DatabaseConfig.html","title":"连接数据库","keywords":"","body":"连接数据库 在 db 插件的配置目录下，有一个 database.xml 文件，用来配置数据库的连接参数。 一个典型的配置文件如下： org.h2.Driver jdbc:h2:../db/DB;AUTO_SERVER=TRUE;IFEXISTS=TRUE sa Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 01:42:06 "},"Dao.html":{"url":"Dao.html","title":"基本操作","keywords":"","body":"数据库操作 所有的数据库操作，都被封装在接口Dao中。数据库配置中配置的每一个逻辑数据库连接，都会生成一个 Dao 对象实例，这个对象会读取对应的 rdmx 文件内容，实现对 O-R Mapping 的支持。 1. 简单的增删改 如果有一个人员表，有人员 ID 与 NAME 字段，经过 O-R Mapping，可以定义一个 Person 类如下： public class Person { private String id; private String name; ...get/set } 向数据库中插入一个人员对象 Person person = new Person(); p.setId(Utils.randomUUID64()); p.setName(\"韦小宝\"); dao.insert(person); 插入人员列表 List list = Arrays.asList(person1, person2); dao.insert(list); 更新一个人员对象 dao.update(person); 删除一个人员对象 dao.delete(person); 2. NeoBean O-R Mapping 中的 Object，如果都对应的定义一个 Java Bean，有时并不那么美好，也没有必要。因此，一个特殊的 Map 对象 NeoBean 诞生了。它持有 Entity 的定义，它提供的 setValue，getValue 等函数可以根据 Entity 数据类型提供类型检查和转换，是一个很重要的对象。 dao.newNeoBean(\"Person\") 创建一个空的对应 Person Entity 的 NeoBean dao.makeNeoBean(\"Person\", someObj) 也是创建一个对应 Person Entity 的 NeoBean，并把对象 someObj 中与 Person 的属性名相同的属性值设置给这个 NeoBean 3. 查询 dao.select() 返回一个 Select 对象，查询的写法看上去有点像 Sql。比如查询所有姓李的人员可以这样写： List person = dao.select().from(\"Person\").where(\"name\", Op.like, \"李%\").queryForList(Person.class); Select 对象实现了 ISelect 接口，这个接口描述了对查询结果的处理方式，可以参考 API 看一下具体的使用方法。 4. 条件更新与删除 同查询类似，dao.update() 返回一个 Update 对象，dao.delete()返回一个 Delete 对象，这些都比较简单，需要注意他们的执行都要调用一下自己的 execute 函数。 // 删除 id 为 001 的人员 dao.delete(\"Person\").byId(\"001\"); dao.delete(\"Person\").where(\"id\", \"001\").execute(); // 计划表有年份和编号两个字段做主键，删除2020年5号计划 dao.delete(\"Plan\").byKey(2020, 5); dao.delete(\"Plan\").where(\"year\", 2020).and(\"number\", 5).execute(); // 所有人的岁数加1 dao.update(\"Person\").set(\"age\", '+', 1).execute(); // id为001的人员改名为张三并且年龄加1 dao.update(\"Person\").set(\"name\", \"张三\").set(\"age\", '+', 1).where(\"id\", \"001\").execute(); Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-20 16:05:05 "},"Condition.html":{"url":"Condition.html","title":"查询条件","keywords":"","body":"查询条件 查询条件是用 C 对象来封装的。查询操作符定义为一个枚举 Op： public enum Op { Like(\" like \"), NotLike(\" not like \"), Equal(\"=\"), NotEqual(\"<>\"), Greater(\">\"), Less(\"=\"), LessEqual(\"简单条件 C.make(); // 定义一个空条件 C.make(\"qty\", 100); // 定义一个条件，qty = 100，默认的 Op 是 Equal C.make(\"qty\", Op.Less, 100); // qty 组合条件 简单条件可以通过 and or 链接起来成为组合条件： C.make(\"qty\", 100).and(\"name\", \"111\"); 当需要用 or 链接两个组合条件时，写法如下： C.make(...).and(...).or(C.make(...).and(...)); Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-19 12:01:53 "},"Join.html":{"url":"Join.html","title":"关联查询","keywords":"","body":"多表关联 虽然我们提倡写简单的 sql，也有一些技术和技巧可以避免关联操作。但是有时还是免不了需要进行多表关联查询。 表关联是数据库的概念，数据库只是数据保存的一种古老的方法，随着大数据应用的发展，数据存储也有了更多的方式。所以结构化数据从概念上，是可以抽象为对象与属性的，这样才能适应更多的底层数据操作要求。 关联关系可以抽象为一个对象的特殊属性，把两个数据对象链接起来，我们称为链接属性，对于主对象来说，它原来的一个（或几个）基本数据类型的属性被定义为一个链接属性，指向另一个数据对象。 关联定义 两个表的关联关系可以在rdmx中进行定义，比如人员表 T_RY有一个所属部门ID字段，那么可以为人员表 T_RY建一个链接属性如下图所示: 当要查询人员信息时，可以用 '.' 访问链接属性的子属性： dao.select(\"id,name,org.name\").from(\"Person\").where(\"org.name\", Op.like, \"%北京%\") 上面的例子是返回机构名称中含有 北京 的所有人员 id,人员 name 和该人员所属机构的 name。链接属性的子属性可以加别名作为返回数据的属性名： dao.select(\"id,name,org.name:orgName\").from(\"Person\") 一对多关联 人员表与家庭成员表是一对多关系，可以选择人员表的 id 属性关联家庭成员表的人员 id 属性，建立一个链接属性，同时把列表属性标记选上。 这时候查询 family 属性 依然是用 . 来指定子属性，用 select 查询时写法上没什么区别。 多对多关联 多对多关联，应该用一个中间表将其转化为两个一对多关联。如果要对这三个对象进行关联，应以中间表为主对象。 临时关联 定义关联关系，是一个需要仔细考虑的工作，有些关联关系可能由于各种原因并未定义在模型中，我们可以在查询时临时增加关联定义来解决问题。参看 Select 源码的 extraLink 函数。 /** * 添加一个并未定义在rdmx模型里面的额外的链接 * * @param name link的名称 * @param fields 主对象属性列表，以逗号分割 * @param targetEntityName 链接对象名 * @param targetFields 链接对象属性列表，以逗号分隔 * @return */ public Select extraLink(String name, String fields, String targetEntityName, String targetFields) 需要注意的问题 通过链接属性的查询，如果链接对象的查询条件写在 where 子句中，因为默认的是 LeftJoin，当链接对象条件不满足时，主对象也查不出数据。可能这并不是想要的结果，这时可以把链接对象的条件用下面的函数来写： Select setLinkCnds(String link, C cnd) Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-19 11:50:10 "},"Transaction.html":{"url":"Transaction.html","title":"事务","keywords":"","body":"数据库事务 当多个数据库操作需要封装到一个事务时，只要将代码封装为一个 Runnable 即可，举例如下： dao.transaction(new Runnable(){ public void run() { dao.insert(...); dao.delete(...); } }); 建议用箭头函数的写法： dao.transaction(()->{ dao.insert(...); dao.delete(...); }); 有时候，一个事务成功完成后，需要返回一个值或对象，这时候数据库操作就不能封装为 Runnable，而要封装为能返回对象的 Supplier。举例如下： boolean result = dao.transaction(new Supplier(){ Boolean get() { dao.insert(...); dao.delete(...); return dao.select(...).count()>10; } }); 或者： boolean result = dao.transaction(()->{ dao.insert(...); dao.delete(...); return dao.select(...).count()>10; }); 默认的事务处理级别是 TRANSACTION_READ_COMMITTED，如果需要改变处理级别，可以使用下面版本的函数： void transaction(int level, Runnable atom); T transaction(int level, Supplier atom); level 的取值为以下四个值之一： Connection.TRANSACTION_READ_UNCOMMITTED Connection.TRANSACTION_READ_COMMITTED Connection.TRANSACTION_REPEATABLE_READ Connection.TRANSACTION_SERIALIZABLE Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-19 09:56:27 "},"Service.html":{"url":"Service.html","title":"服务开发","keywords":"","body":"服务开发 服务开发是 Rainbow 的一个重点，service 插件实现了对服务的管理。 基本上大部分的开发工作，都是开发服务，那么什么是服务呢？简单的说，就是 Java 的接口，我们约定以 Service 作为名字后缀的 Java 接口，就是服务的定义；以 ServiceImpl 作为名字后缀的 Java 类，就是服务的实现，它必须实现对应的接口，服务实现类要标记@Bean，由插件容器管理。 服务的接口与实现，都要注册在服务注册表上。当写一个新的服务插件时，首先要依赖 service 插件，然后 Activator 派生自 ServiceBundleActivator 就可以了，这个 Activator 会自动发现所有的服务与实现并完成注册工作。 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 03:09:05 "},"ServiceTest.html":{"url":"ServiceTest.html","title":"服务测试","keywords":"","body":"服务测试 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 01:09:50 "},"UnitTest.html":{"url":"UnitTest.html","title":"怎么写单元测试","keywords":"","body":"单元测试 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 00:50:54 "},"ExportService.html":{"url":"ExportService.html","title":"对外提供服务","keywords":"","body":"对外提供服务 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 00:50:54 "},"Jetty.html":{"url":"Jetty.html","title":"Web 插件","keywords":"","body":"Web 插件 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 01:09:50 "},"Deploy.html":{"url":"Deploy.html","title":"部署","keywords":"","body":"实施部署 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 00:50:54 "},"Maintain.html":{"url":"Maintain.html","title":"运行监控","keywords":"","body":"运行监控 Copyright © jinghui70 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 01:39:53 "}}